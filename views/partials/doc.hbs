<p><strong>A Modular <span class="key4">requirements</span> Engineering Framework for Web-Based Toolchain Integration</strong></p><p><strong>Abstract:</strong> </p><p>Requirements Engineering (RE) <span class="key1">tools</span> and more generally the whole Software Engineering toolchain follow the strong trend towards web-based interface. This allows the analyst to use their <span class="key1">tools</span> in a "Software as a Service" mode either from a local company server or directly in the Cloud. Such deployments also ease toolchain <span class="key7">integration</span> by connecting their respective API through secured web-services, possibly using specific software lifecycle interoperability standards. In this <span class="key5">tool</span> demonstration, we illustrate the results of the rewrite process of a major <span class="key4">requirements</span> Engineering <span class="key5">tool</span> towards this purpose. Our tooling has the following key features: (i) it supports rich <span class="key4">requirements</span> models based on goal-oriented RE, (ii) it is implemented as a collaborative <span class="key9">concept</span> server based on Eclipse Modelling technology and (iii) it exposes a REST interface supporting <span class="key3">model</span> building, <span class="key6">diagram</span> edition, history retrieval, snapshot management, collaborative mode, <span class="key8">user</span> authentication and project management. The following scenarios will be demonstrated (1) collaborative edition of a shared RE model, (2) rich service composition with application lifecycle management <span class="key1">tools</span> and (3) easy web-component <span class="key7">integration</span> in third-party <span class="key2">web</span> interfaces.</p><p>SECTION I.</p><h2>Background and Motivation</h2><p>The landscape of <span class="key4">requirements</span> <span class="key1">tools</span> is mostly composed of two kinds of complementary tools: </p><ul><li><em>Requirements Engineering</em> (RE) <span class="key1">tools</span> support the whole process to produce high quality requirements, this includes elicitation from various sources, analysis (e.g. building goal trees or performing obstacle analysis [1]), specification (e.g. using templates like Volere [2]) and validation (e.g. review of goal models or derived documents). There are either specialised RE <span class="key1">tools</span> relying on a strong <span class="key3">model</span> like Objectiver [3] and RE-TOOLS [4]. Many recent system engineering and enterprise architecture <span class="key1">tools</span> also propose some form of RE support.</li><li><em>Requirements Management</em> (RM) <span class="key1">tools</span> focus on providing a reliable and adequate persistent storage for import/export, traceability, versioning and change management. Examples of <span class="key1">tools</span> are DOORS [5] and Reqtify [6].</li></ul><p>The classical design of RE <span class="key1">tools</span> is a 2-tier desktop application with a repository either locally or as shared database for working on multiple projects and in team. Such repositories can be synchronised with a RM <span class="key5">tool</span> which is usually a 3-tier system composed of an interface (desktop or web), an API for managing <span class="key4">requirements</span> and an efficient database.</p><p>The strong trend is to move to SaaS (Software as a Service) paradigm. Reducing client <span class="key4">requirements</span> to a recent <span class="key2">web</span> browser strongly eases installation and updates. It also removes infrastructure needs in case the companies agree to use an <span class="key10">external</span> Cloud. However this later scenario requires to address non-trivial security and confidentiality requirements.</p><p>Beyond those operation benefits, a SaaS deployment also provides more efficient support of RE activities by easing <span class="key7">integration</span> and teamwork. In addition, it enables quite powerful <span class="key7">integration</span> scenarios such as the inclusion of “live” RE artefacts (like references, definitions, diagrams, <span class="key3">model</span> queries,…) in other Application Lifecycle Management (ALM) <span class="key1">tools</span> at design, testing or maintenance stages.</p><p>In this <span class="key5">tool</span> demo, we illustrate such scenarios based on the SaaS migration of Objectiver <span class="key5">tool</span> which is dedicated to KAOS (Keep All Objective Satisfied), a Goal-Oriented <span class="key4">requirements</span> Engineering method [1].</p><p>SECTION II.</p><h2>Architecture of a Web-Based RE Tooling</h2><p>Two major <span class="key4">requirements</span> for moving to a SaaS <span class="key3">model</span> are: </p><ul><li><em>on the client side:</em> a powerful web-based framework for <span class="key6">diagram</span> edition and <span class="key3">model</span> navigation</li><li><em>on the server side:</em> a reliable application server offering a rich API for model-edition and a <span class="key9">concept</span> repository.</li></ul><p>Our design relies on two key enablers. On the client side, there are now mature JavaScript <span class="key6">diagram</span> libraries [7]. On the server side, the Eclipse Modelling Framework [8] is an industry-strength meta-modelling framework widely used in the Eclipse ecosystem. <span class="key9">concept</span> repositories like Connected Data Objects (CDO) and EMF-Store have been developed on top of it. We selected the former technology which supports fine-grained locking and versioning while the later relies on a check-in/out mechanism. We bundled it as a console application with a generic REST API as middle-tier. The resulting architecture is depicted in Figure 1 and is composed of: </p><ul><li><em>various clients</em>, possibly embedded in third party tools.</li><li><em>a REST API</em> providing services for <span class="key3">model</span> and <span class="key6">diagram</span> edition, history, snapshots, <span class="key8">user</span> authentication and project management [9]. It also enables third party <span class="key7">integration</span> of RE artefacts extracted from the repository, not only as data but also as embedded web-content.</li><li><em>a back-end</em> composed of the <span class="key3">model</span> repository and a collection of plugins enabling both web-services and <span class="key8">user</span> interface extensions.</li></ul><p>SECTION III.</p><h2>Some Interesting Scenarios</h2><h3>A. Collaborative Modelling Scenarios</h3><p>The <span class="key9">concept</span> repository supports locking at different levels (concept, diagram, package) but also versioning and history browsing, enabling the development of different collaborative models. By default, the <span class="key5">tool</span> provides a permissive collaboration <span class="key3">model</span> where concurrent editions will just overwrite each other and trigger warnings (such as “the <span class="key9">concept</span> you are editing has been deleted”). The availability of the <span class="key9">concept</span> history allows one to easily identify the concurrent editing <span class="key8">user</span> and engage in a discussion with him. Beyond this, other collaborative models are also possible, e.g. automatic lock when editing a <span class="key6">diagram</span> resulting in read-only mode for other users accessing it.</p><h3>B. Service Level <span class="key7">integration</span> Scenarios</h3><p>Two kinds of scenarios are supported: first, our REST API can be used to perform “CRUD” operations on the <span class="key3">model</span> and its representations. This means concepts like requirements, expectations, or obstacles can be queried, imported, added in diagrams or even laid out using dedicated algorithms. This scenario can be used to synchronise <span class="key4">requirements</span> with an <span class="key10">external</span> tool. Second, it is also possible to invoke <span class="key10">external</span> services by wrapping them into a plugin. Base on this, <span class="key10">external</span> <span class="key1">tools</span> can be notified of changes in real-time.</p><p>From a security perspective, those facilities might cause a threat. For this reason authentication is required through a specific service that returns a security token that can be used to implement single sign-on within the target <span class="key5">tool</span> chain.</p><h3>C. <span class="key8">user</span> Interface Level <span class="key7">integration</span> Scenarios</h3><p>Going one step beyond interaction between web-services, web-components can be integrated in two ways. First, specific editors can be added as plugins in order to edit specific attribute types. For example, Figure 2 shows an editor for specification under the Gherkin format. Second, our web-components can be embedded into <span class="key10">external</span> <span class="key8">user</span> interfaces. A common example is to embed a read-only goal <span class="key6">diagram</span> on a wiki page as shown in Figure 3. The goal <span class="key6">diagram</span> is guaranteed to be up to date and double clicking on it will lead to the full editor (if the <span class="key8">user</span> has the access rights). </p><p>SECTION IV.</p><h2>Status and Next Steps</h2><p>We are currently focusing on <span class="key5">tool</span> <span class="key7">integration</span> inside companies. A version hosted on a Cloud infrastructure is under development. An <span class="key7">integration</span> SDK is also being documented. Our future work will extend our support towards standard RE exchange formats and enrich the platform extensibility.</p>